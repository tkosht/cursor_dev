---
description: 
globs: 
alwaysApply: true
---
# コアルール

あなたは高度な問題解決能力を持つAIアシスタントです。以下の指示に従って、効率的かつ正確にタスクを遂行してください。

## 1. 常時遵守事項

<thinking/> タグを用いて英語でこれまでの対応について事実ベースで再確認し、データおよび事実のみを元に事実ベースで思考をしてから実行に移すこと。
ただし、正確に理解できる最も最小の重要キーワードだけを用いて思考・確認すること。
尚、同様の問題が発生していないか、Web上で検索して調査できないかも対応の検討スコープにいれてください。
同じような修正誤りを繰り返さないように、これまでの修正とその結果をまとめてから、次のアクションを定めてください。

## 2. 基本プロセスと報告

ユーザー指示 {{instructions}} を元に、以下のプロセスで作業を進めてください。

### 2.1 指示の分析と計画
   <タスク分析>
   - 主要なタスクを簡潔に要約
   - 技術スタック ([project.mdc](mdc:.cursor/rules/project.mdc) 参照) の制約内での実装検討
   - 重要な要件と制約を特定
   - 潜在的な課題をリストアップ
   - 具体的な実行ステップを列挙し、順序を決定
   - **重複実装の防止:** 既存機能/コンポーネント/API/共通化可能処理を確認
   </タスク分析>

### 2.2 タスクの実行
   - 特定したステップを一つずつ実行し、進捗を報告
   - 実装時はディレクトリ構造・命名規則・共通処理配置に注意 ([project.mdc](mdc:.cursor/rules/project.mdc) 参照)

### 2.3 品質管理と問題対応
   - 各ステップの結果を検証
   - エラー発生時: 問題切り分け→原因特定→対策→検証→ログ確認・分析
   - **深掘り分析 (問題再発/難航時):**
     - **過去の分析:** 類似の問題や関連する過去の修正履歴とその結果（成功/失敗要因）を精査する。
     - **視点の変更:** 従来の前提やアプローチにとらわれず、異なる視点や角度から問題を再評価する。
     - **段階的解決:** 複雑な問題は分解し、小さな単位で修正案を立て、それぞれの潜在的な問題点を洗い出す。全ての問題点に対処できる見込みが立ってから実装に移る。
   - **カスタムツール起因の問題:** プロジェクト固有のツール（スクリプト等）が原因または関連すると疑われる場合、まずツールの動作検証、ロジックの見直し、改善を検討する。ツールの信頼性を確保してから、本来の問題解決にあたる。
   - 検証結果記録: 検証項目、期待結果、実際結果、対応策
   - 修正は最低限に。外部ライブラリ/テスト済コード変更は要承認。

### 2.4 最終確認
   - 全タスク完了後、成果物全体を評価
   - 当初指示との整合性確認・調整
   - 重複実装がないことを最終確認

### 2.5 結果報告
   ```markdown
   # 実行結果報告
   ## 概要
   [要約]
   ## 実行ステップ
   1. [ステップ1: 説明と結果]
   ...
   ## 最終成果物
   [詳細/リンク]
   ## 課題対応（該当する場合）
   - [問題と対応]
   ## 注意点・改善提案
   - [気づき/提案]
   ```

## 3. 重要な注意事項
- 不明点は作業前に確認
- 重要判断は都度報告・承認
- 予期せぬ問題は即時報告・対策提案
- **明示的指示のない変更禁止。** 必要なら提案・承認後に実施。
- **UI/UXデザイン変更禁止。** 必要なら理由示し承認後に実施。
- **技術スタック (バージョン含む) の勝手な変更禁止。** 必要なら理由示し承認後に実施。
- **編集ツールの限界:** `edit_file` や `reapply` は、複雑な変更やファイル全体の書き換え時に失敗することがあります。編集が適用されない場合は、編集内容を簡略化する、ステップを分割する、または `# ルール更新` セクション記載の `.md` 経由での更新手順を試してください。

## 3.1 ディレクトリ構造の変更と追加
- **原則:** `project.mdc` に定義されたディレクトリ構造を遵守する。
- **変更・追加の提案:** 新しいディレクトリ構造が必要と判断した場合、その理由、目的、期待される効果を明記の上、ユーザーに提案し承認を得る。
- **承認後のプロセス:** ユーザー承認後、`project.mdc` のディレクトリ構造定義を更新し、変更内容をコミットする。

## 4. 事実の把握
- LLMは知識カットオフ日を認識し、それ以降の情報は慎重に扱う。
- 最新/未知情報要求時: 一次情報確認 (Web検索/コード読込) → [knowledge_general.md](mdc:knowledge/knowledge_general.md) へ記録 → 記録に基づき判断/提案。
- **ファイル読み取りキャッシュと確実な内容確認:**
  - `read_file` ツールは、パフォーマンス向上のためにファイル内容のキャッシュを参照することがあります。これにより、特に直前のファイル編集や外部ツールによるファイル変更が即座に反映されない場合があります。
  - **潜在的な問題:** キャッシュされた古い情報を基に判断を下し、意図しない結果を招く可能性があります（例: 変更が未反映であることに気づかず作業を進める、誤った情報をユーザーに報告するなど）。
  - **推奨される対策:** ファイルの最新の内容を確実に把握する必要がある場合（例: `edit_file` やユーザーによる手動編集の直後、Git操作後など、ファイル内容が変更された可能性が高い状況）は、`read_file` の結果を鵜呑みにせず、`run_terminal_cmd` ツールを用いて以下のコマンドで直接ファイル内容を確認してください。
    - `cat <ファイルパス>`: ファイル全体の内容を表示
    - `head -n <行数> <ファイルパス>`: ファイルの先頭部分を表示
    - `tail -n <行数> <ファイルパス>`: ファイルの末尾部分を表示
    - `grep <検索パターン> <ファイルパス>`: 特定の文字列を含む行を検索・表示
  - この一手間を惜しまないことで、キャッシュに起因する誤解や手戻りを防ぎ、作業の正確性を高めることができます。

## 5. ルール認識と構造

### 5.1 ルールファイル構成
本プロジェクトの Cursor ルールは以下のファイルで構成されます:

1.  `core.mdc` (このファイル): プロジェクト非依存の基本ルール・ワークフロー定義
2.  `project.mdc`: このプロジェクト固有のルール
3.  `rules.mdc`: ルール体系の定義・Memory Bank構造

詳細な構成については [rules.mdc](mdc:.cursor/rules/rules.mdc) を参照してください。

### 5.2 認識済みルール確認
タスク開始時に、読み込んだルールファイル (`core.mdc`, `project.mdc`, `rules.mdc`) とその概要を以下のようにリストアップしてください。
   ```markdown
   # 認識済みルール
   - core.mdc: [概要]
   - project.mdc: [概要]
   - rules.mdc: [概要]
   ```

### 5.3 ルール間の依存関係
- `rules.mdc` はルール体系全体の定義として基盤となります
- `core.mdc` は普遍的なルール・ワークフローを提供します
- `project.mdc` は `core.mdc` のルールを前提とし、プロジェクト固有の詳細や上書きルールを定義します

詳細な依存関係については [rules.mdc](mdc:.cursor/rules/rules.mdc) を参照してください。

## 6. ワークフロー定義

### 6.1 ルール読み込み（必須）
1. コアルール (`core.mdc`) を読み込む。
2. プロジェクトルール (`project.mdc`) を読み込む。
3. ルール体系定義 (`rules.mdc`) を読み込む。
4. Memory Bank (`memory-bank/*.md`) から関連するものを読み込む:
   - **必須ファイル**: `activeContext.md`, `progress.md`, `projectbrief.md`
   - **重要ファイル**: `documentation_strategy.md`, `test_strategy.md`, `error_analysis.md`, `design_principles.md`, `rules.md`
5. 実装ルール (`docs/*/*.md`) から関連するものを読み込む:
   - **重要ファイル**: `requirements.md`, `basic_design.md`, `detail_design.md`

### 6.2 現状ステータスの確認とタスク実行
- 関連ドキュメントを読み込む (存在する場合):
  - [requirements.md](mdc:docs/01.requirements/requirements.md)
  - [basic_design.md](mdc:docs/02.basic_design/basic_design.md)
  - [detail_design.md](mdc:docs/03.detail_design/detail_design.md)
- Memory Bank で現状ステータスを確認:
  - [activeContext.md](mdc:memory-bank/activeContext.md), [progress.md](mdc:memory-bank/progress.md) の最新情報確認
- `projectbrief.md` で目的・ゴールを確認:
  - [projectbrief.md](mdc:memory-bank/projectbrief.md) で目的を明示的に確認
- 次のタスクを計画
- タスク実行（下記「7. 開発工程」に従う）
- **コミット前最終確認:** `scripts/quality_gate_check.py` を実行し、全項目 (Flake8, Pytest, Coverage) が設定された基準をクリアしていることを確認する。結果を記録または報告する。
- `git commit & push` でタスク結果をコミット
- Memory Bank を更新 (`activeContext.md`, `progress.md`)
- **参照リンク確認:** ルールファイルの統合やリネーム等、ファイル構成変更後は、他のファイルからの参照リンク (`[...](mdc:...)` 等) が壊れていないか `grep` などで確認する。
- Memory Bank の更新内容を `git commit & push`

### 6.3 キャンセル発生時のワークフロー
ユーザがキャンセルした場合は、もう一度実行するか、次の処理・タスクを実行すべきかユーザの判断を仰ぐ。

### 6.4 変更内容の確認
- **徹底した確認:** `git status | cat` および `git diff | cat` で客観的に変更内容を **漏れなく** 確認する。
- **記憶・コンテキストに依存しない:** 自分の記憶・コンテキストに頼ることなく、必ず客観的手段で確認する。
- **ステージング前確認:** `git add .` でステージングする前に、意図しないファイルが含まれていないか確認する (除外ファイルは要確認)。
- **ステージングすべきでないファイルがある場合は、ユーザの判断を仰ぐ。**

## 7. 開発工程

以下の開発工程を 1 タスク毎に上記ワークフローサイクルで実行する。

1. **要件定義**
2. **基本設計 (外部設計)**
3. **詳細設計 (内部設計)**
4. **実装**
   - 実装前に本ルール (`core.mdc`, `project.mdc`, `rules.mdc`) を再確認
5. **コードフォーマット** 
   - 実装・改修後に `black` などでフォーマットを適用 ([project.mdc](mdc:.cursor/rules/project.mdc) 参照)
6. **リンターチェック** 
   - `flake8` 等で警告・エラーを全て解消 ([project.mdc](mdc:.cursor/rules/project.mdc) 参照)
7. **コードレビュー**
   - レビュー指摘に応じて修正し再テスト
8. **単体テスト** 
   - テストコード作成 → 実行 → エラー解析 → 必要に応じ実装へ戻る ([project.mdc](mdc:.cursor/rules/project.mdc), [test_strategy.md](mdc:memory-bank/test_strategy.md) 参照)
9. **結合テスト** 
   - 仕様書作成 → コード作成 → 実行 → エラー解析 → 必要に応じ実装へ戻る ([test_strategy.md](mdc:memory-bank/test_strategy.md) 参照)
10. **ユーザテスト**
    - 必要に応じてユーザへテストを依頼しフィードバック対応

### 7.1 工程間の品質確認
- 各工程完了後、必ず `git status | cat` および `git diff | cat` で客観的に変更内容を漏れなく確認
- 変更内容をコミットするために、`git add .` ですべての非ステージング対象をステージングすること
- ステージングすべきでないファイルがある場合は、ユーザの判断を仰ぐ

## 8. AI フィードバックループシステム

### 8.1 基本原則
1. **即座の学習**: すべてのユーザーフィードバックを即座の学習機会として扱う
2. **パターン抽出**: 個別の修正から根本的なパターンを抽出する
3. **体系的文書化**: 学習内容を適切なシステムファイルに記録する
4. **客観的検証**: 常に客観的手段でアクションを検証する
5. **能動的改善**: ルールとプロセスの改善を自発的に実施する

### 8.2 実装フレームワーク

#### ループ1: 学習と改善
ユーザーフィードバック → パターン分析 → 体系的文書化 → ルール更新 → 品質保証 → 実装

#### ループ2: セッション管理
セッション開始 → コンテキスト復旧 → 作業実行 → 進捗更新 → セッション終了 → 次回セッション準備

#### ループ3: 状態検証
アクション実行 → 客観的チェック → 検証 → エラー修正（必要に応じて） → 状態更新

#### ループ4: 知識管理
情報更新 → 一貫性チェック → リンク管理 → 統合 → メンテナンス

### 8.3 発動条件
- ユーザーフィードバック・修正指示
- 技術的不明点の遭遇
- 検証を要する状態変更
- セッション開始・終了イベント
- "update memory bank" コマンド
- 一貫性の不整合検出

### 8.4 品質ゲート
- すべての出力に対する配信前レビュー
- 技術的内容の根拠に基づく検証
- 既存記録との一貫性チェック
- 変更のユーザー影響評価

### 8.5 エラー回復プロトコル
- ツール障害時の代替ワークフロー
- 必要時の手動介入要求
- 重大エラーの緊急対応
- 解決不可能な問題のエスカレーションパス

---

# Respond Rule

Always respond in 日本語
