# クローラー開発の知識集約

## 1. アーキテクチャ設計

### 1.1 責務分離
- AdaptiveCrawlerとAdaptiveURLCollectorの分離により、各クラスの役割が明確化
- URLの収集とデータの抽出を分離することで、保守性と拡張性が向上
- 基底クラス（BaseCrawler）による共通機能の提供

### 1.2 エラーハンドリング階層
1. アプリケーション固有のエラー
   - URLCollectionError: URL収集に関するエラー
   - ExtractionError: データ抽出に関するエラー
   - NoValidDataError: 有効なデータが得られない場合

2. システムエラー
   - MaxRetriesExceededError: リトライ上限超過
   - RateLimitError: レート制限到達

### 1.3 設定管理
- 設定値は辞書形式で集中管理
- デフォルト値の適切な設定
- 環境変数との連携

## 2. 実装のベストプラクティス

### 2.1 メソッド設計
- 単一責任の原則を遵守
- 複雑性を下げるためのメソッド分割
- 適切な名前付けによる可読性向上

### 2.2 エラーハンドリング
- 段階的なエラー処理の実装
- 詳細なエラーログの記録
- リトライ機構の実装

### 2.3 非同期処理
- asyncio/awaitの適切な使用
- 同時実行数の制御
- コンテキストマネージャの活用

## 3. テスト戦略

### 3.1 テストの種類
1. 単体テスト
   - 各クラスの独立した機能テスト
   - エラーケースの網羅的テスト

2. 結合テスト
   - 実際のURLを使用したテスト
   - モックを避けた実環境テスト
   - 同時リクエストのテスト

### 3.2 テストの原則
- テストケースの独立性確保
- 実際のURLを使用した検証
- エラーケースの十分なカバレッジ

## 4. パフォーマンス最適化

### 4.1 リソース制御
- 同時リクエスト数の制限
- タイムアウト設定
- リトライ間隔の調整

### 4.2 キャッシュ戦略
- パターンのキャッシュ
- 重複URLの排除
- 検索結果のキャッシュ

## 5. 保守性向上のポイント

### 5.1 コード品質
- 型ヒントの活用
- 詳細なドキュメント
- リンターエラーの解消

### 5.2 ログ管理
- 適切なログレベルの使用
- エラー情報の詳細化
- デバッグ情報の充実

### 5.3 設計パターン
- 依存性注入の活用
- ファクトリーパターンの使用
- アダプターパターンの適用

## 6. 今後の改善点

### 6.1 短期的な改善
- SQLAlchemy 2.0対応
- テストカバレッジの向上
- 同時リクエスト処理の改善

### 6.2 中長期的な改善
- パフォーマンスモニタリングの強化
- エラー検知の自動化
- スケーラビリティの向上

# テストコードの設計・実装に関する重要ルール

## 1. 実際のビジネスドメインを使用する
- ✅ 実在する企業、取引所、ニュースサイトなどの実際のドメインを使用
- ❌ `example.xx.xx`のような架空のドメインは使用しない
- 理由：本番環境に近い状態でのテストが目的のため

## 2. 外部接続を含むテスト
- ✅ 実際のURLに対してリクエストを行い、実データでテスト
- ❌ モックやスタブによる外部接続の偽装は行わない
- 理由：実際の外部APIやWebサイトとの連携における問題を早期発見するため

## 3. テストケースの具体性
- ✅ 具体的なビジネスケース（IR情報、決算短信、適時開示など）に基づくテスト
- ❌ 一般的すぎる、または抽象的なテストケース
- 理由：実際のユースケースに即した動作確認が必要なため

## 4. データ検証の厳密性
- ✅ 業務要件に基づく具体的な検証（日付形式、タイトル長、内容の最小長など）
- ❌ 単なる型チェックや存在確認のみ
- 理由：実際のビジネスデータとしての品質確保のため

## 5. エラーケースの具体性
- ✅ 実際のビジネスシナリオに基づくエラーケース（信頼性の低いドメイン、不適切なURLなど）
- ❌ 一般的なエラーケースのみ
- 理由：実運用で発生しうる具体的な問題への対応力を確保するため

## 6. テストの独立性と再現性
- ✅ 各テストは独立して実行可能で、結果が再現できること
- ❌ テスト間の依存関係や実行順序への依存
- 理由：テストの信頼性と保守性を確保するため

## 7. ログと例外処理
- ✅ 具体的なエラーメッセージと詳細なログ出力
- ❌ 一般的なエラーメッセージや最小限のログ
- 理由：問題発生時の原因特定と対応を容易にするため

## 8. パフォーマンステスト
- ✅ 実際の運用を想定した同時リクエスト数やタイムアウト設定
- ❌ 理想的すぎる、または非現実的な設定値
- 理由：実運用時のパフォーマンス問題を事前に検出するため

## 9. 設定値の妥当性
- ✅ 実運用を想定した現実的な設定値（タイムアウト、リトライ回数など）
- ❌ 開発環境のみを想定した設定値
- 理由：本番環境での安定動作を確保するため

## 10. テストデータの品質
- ✅ 実際のビジネスデータに基づくテストデータ（実在する企業コード、実際のIR情報フォーマットなど）
- ❌ 形式的なダミーデータ
- 理由：実データでの動作検証が必要なため

# 実装パターン

これらのルールを適用する際の具体的なパターンについては、`docs/knowledge/implementation_patterns.md`を参照してください。