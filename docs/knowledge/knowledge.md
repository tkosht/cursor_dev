# 開発知識ベース

## LLMメトリクス管理
1. エラー発生時のメトリクス更新
   - プロンプトのトークン数は記録する（入力は処理されたため）
   - 完了トークン数は0とする（出力が生成されなかったため）
   - エラーカウントを増加させる
   - コストは現時点では0（Gemini APIが無料のため）

2. メトリクスのリセット
   - すべてのフィールドを初期値に戻す
   - 累積値（total_tokens, total_cost）もリセット
   - エラーカウントもクリア

3. レイテンシ計測
   - 処理開始時と終了時の時刻を記録
   - エラー発生時も計測を継続
   - 非同期処理全体の時間を計測

## エラー処理
1. 入力バリデーション
   - 空のコンテンツは専用のエラーメッセージを返す
   - APIキーの存在チェックは初期化時に実施

2. APIエラー処理
   - エラーカウントを増加させてから例外を再送出
   - リトライ可能なエラーは指数バックオフで再試行
   - 最大リトライ回数に達した場合は諦める

3. レスポンス処理
   - 空のレスポンスは空文字列として扱う
   - JSONパースエラーはデフォルト値を返す
   - 不正なレスポンス形式は適切なエラーメッセージを設定

## テスト設計
1. モックの活用
   - 外部APIの動作をモックオブジェクトでシミュレート
   - 非同期処理には`asyncio.Future`を使用
   - サイドエフェクトで複数の応答パターンを設定可能

2. テストケースの分類
   - 正常系：基本的な機能の確認
   - 異常系：エラー処理の確認
   - エッジケース：境界値や特殊な入力の確認
   - 統合テスト：複数機能の連携確認

3. テストカバレッジ
   - 90%以上を目標とする
   - 未カバーの部分は意図的に除外した理由を記録
   - 重要なビジネスロジックは100%を目指す

4. テストの保守性
   - テストケースは目的と期待値を明確に記述
   - 共通の前提条件は`fixture`として定義
   - パラメータ化テストで類似ケースをまとめる

## ベストプラクティス
1. コード品質
   - Pythonの型ヒントを積極的に活用
   - docstringでメソッドの仕様を明確に記述
   - ログ出力で処理の流れを追跡可能に

2. エラー処理
   - 例外は適切な粒度で定義
   - エラーメッセージは具体的に記述
   - リトライは指数バックオフで実装

3. メトリクス収集
   - 処理時間は必ず計測
   - エラー発生時も可能な限り情報を収集
   - 累積値と現在値を適切に管理 