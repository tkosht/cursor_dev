# 知識ベース

## 外部サイトへのアクセス制御
### スコープ: HTTP通信、クローリング
- ブラウザライクな振る舞いの重要性
  - User-Agentだけでなく、全てのヘッダーをブラウザに合わせる
  - Accept-Encodingは対応可能な圧縮形式のみを指定
  - キャッシュ制御を適切に設定（no-cache, Pragma）
  - Refererヘッダーの活用（検索エンジン経由のアクセスを装う）

- レート制限への対応
  - 同時接続数の制限（max_concurrent=1）
  - アクセス間隔の確保（5秒以上）
  - タイムアウト設定の最適化（connect: 30秒, read: 45秒）

### 再利用場面
- 外部サイトへのクローリング実装時
- アクセス制御の設計時
- エラーハンドリングの実装時

## テストコード設計
### スコープ: テスト実装、品質管理
- 実サイトを使用したテストの重要性
  - モックの使用は避け、実際の環境での動作を確認
  - 外部接続エラーも含め、自らの実装を優先的に確認
  - サイトごとの特性を考慮したテストケース設計

- 適応的機能のテスト手法
  - 異なるサイト構造での動作確認
  - エラーケースの網羅的なテスト
  - レート制限などの実運用を想定した検証

### 再利用場面
- クローラーのテスト実装時
- 外部サイトとの連携機能のテスト時
- エラー処理の検証時

## LLMとの通信制御
### スコープ: LLM連携、エラーハンドリング
- タイムアウト設定の重要性
  - 適切なタイムアウト値の設定
  - エラーハンドリングの実装
  - リトライ処理の組み込み

- エラー検出と対応
  - エラーの種類に応じた適切な処理
  - ログ出力による状況の記録
  - 段階的なエラーハンドリング

### 再利用場面
- LLMを使用した機能の実装時
- 外部APIとの連携時
- エラー処理の設計時

# テスト実行に関する知識

## テストカバレッジの管理
- **対象スコープ**: プロジェクト全体のテスト
- **知識内容**:
  1. カバレッジの目標設定
     - 重要なモジュールは90%以上を目指す
     - プロジェクト全体で最低40%を維持
  2. カバレッジの分布管理
     - 機能の重要度に応じて優先度を設定
     - コアモジュールは高カバレッジを維持
  3. カバレッジ改善の方針
     - 未テストの分岐やエッジケースを特定
     - テストケースの追加と改善を継続的に実施
- **再利用場面**:
  - 新機能追加時のテスト設計
  - 既存機能のテスト改善
  - コードレビュー時の品質チェック

## 非同期テストの安定性確保
- **対象スコープ**: 非同期処理を含むテスト全般
- **知識内容**:
  1. タイムアウト設定
     - テストごとに適切なタイムアウト値を設定
     - 外部接続を含むテストは余裕を持った設定
  2. 非同期テストの構成
     - pytest.markの適切な使用
     - asyncioモードの設定確認
  3. エラーハンドリング
     - 非同期処理特有の例外に対応
     - リトライメカニズムの実装
- **再利用場面**:
  - 新しい非同期テストの実装時
  - テストの安定性改善時
  - CI/CD環境の構築時

## キャッシュ制御の最適化
- **対象スコープ**: HTTPリクエストを行う全てのモジュール
- **知識内容**:
  1. キャッシュヘッダーの設定
     - `no-cache`と`Pragma: no-cache`の組み合わせ
     - 古いプロキシサーバーへの対応
  2. 設定の統一化
     - プロジェクト全体で一貫した設定
     - 必要に応じてオーバーライド可能な構造
  3. 効果の検証
     - キャッシュ制御の動作確認テスト
     - 実際のリクエストでの検証
- **再利用場面**:
  - 新しいクローラーの実装時
  - キャッシュ関連の問題調査時
  - パフォーマンス最適化時

# モデル間の依存関係管理
- **対象スコープ**: SQLAlchemyモデル全般
- **知識内容**:
  1. リレーション設定
     - モデル間の依存関係を明確に定義
     - 循環参照を避ける設計
  2. マッピング設定
     - 適切なカラム型とリレーション型の選択
     - 外部キー制約の適切な設定
  3. 初期化順序
     - モデルの初期化順序を考慮
     - 依存関係に基づく適切な順序付け
- **再利用場面**:
  - 新しいモデルの追加時
  - モデル間の関係修正時
  - データベース設計の見直し時