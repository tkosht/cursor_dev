# 市場分析システムの知識ベース

## エンティティ構造化
### スコープ
- app/market_analyzer.py の _create_entity メソッド

### 知識内容
1. 必須フィールド
   - id: エンティティの一意識別子
   - name: エンティティの名称
   - type: エンティティの種別（COMPANY/PRODUCT/SERVICE）
   - content: エンティティの説明内容
   - source: 情報源
   - timestamp: 作成/更新時刻
   - impact: 市場への影響度（0.0-1.0）

2. プロパティの制約
   - 既存のキーは上書きしない（データの一貫性を保持）
   - 値の型は文字列、数値、真偽値のみ許可（Neo4jの制約に準拠）

### 再利用場面
- 新規エンティティ作成時
- エンティティ構造の変更時
- データバリデーション実装時

## リレーションシップ管理
### スコープ
- app/market_analyzer.py の _validate_relationship メソッド

### 知識内容
1. 関係タイプの制約
   - INFLUENCES: 影響関係
   - COMPETES: 競合関係
   - DEVELOPS: 開発関係
   - PARTICIPATES: 参加関係

2. 必須プロパティ
   - source: 関係の起点エンティティ
   - target: 関係の終点エンティティ
   - type: 関係の種別
   - strength: 関係の強度（0.0-1.0）
   - timestamp: 作成時刻

### 再利用場面
- 新規リレーションシップ作成時
- リレーションシップのバリデーション実装時

## 市場影響度計算
### スコープ
- app/market_analyzer.py の _calculate_impact_score メソッド

### 知識内容
1. 影響度の構成要素
   - 基本スコア: 50%（エンティティの直接的な重要度）
   - トレンド影響: 30%（市場トレンドからの影響）
   - 企業動向: 20%（関連企業の動向による影響）

2. スコア正規化
   - すべての要素を0.0-1.0の範囲に正規化
   - 重み付け合算後も0.0-1.0の範囲を保証

### 再利用場面
- 影響度計算ロジックの修正時
- 新規要素の追加時
- スコアの調整時

# トレンド分析の設計と実装

## トレンド分析の評価要素

### 1. トレンドの重要度
- 市場影響度（40%）
  - Geminiの分析結果から市場への影響度を評価
  - 0.0〜1.0の範囲で数値化
- 企業重要度（40%）
  - トレンドに関連する企業の重要性を評価
  - 企業の規模、市場シェア、業界での影響力などを考慮
- 言及頻度（20%）
  - トレンドが言及される頻度を評価
  - 時系列での変化も考慮

### 2. トレンドの新規性
- 初出時期（40%）
  - トレンドが最初に言及された時期を評価
  - 最近のトレンドほど高いスコア
- 言及頻度の変化（40%）
  - 言及頻度の時系列変化を評価
  - 急激な増加は新規性が高いと判断
- 類似性（20%）
  - 既存トレンドとの類似度を評価
  - 類似性が低いほど新規性が高い

### 3. トレンドのカバレッジ
- 企業数（40%）
  - トレンドに関連する企業の総数を評価
  - より多くの企業が関与するトレンドを重視
- 市場シェア（40%）
  - 関連企業の市場シェアを評価
  - 市場シェアの大きい企業の関与を重視
- 業界分布（20%）
  - 関連企業の業界分布を評価
  - 複数業界に影響するトレンドを重視

## 実装上の注意点

### エラーハンドリング
- 各評価メソッドは独立して例外をキャッチ
- エラー発生時は中間値（0.5）を返す
- エラーログを適切に記録

### 重み付けの考え方
- 主要な評価要素には40%の重みを設定
- 補助的な要素には20%の重みを設定
- すべての重みの合計が100%になるように調整

### 正規化
- すべての評価値は0.0〜1.0の範囲に正規化
- max(0.0, min(1.0, value)) で範囲を制限

### 拡張性
- 各評価メソッドは独立して実装
- 新しい評価要素の追加が容易な設計
- 重み付けの調整が容易

# Neo4j関連の知識

## トランザクション管理
### 最新のNeo4jドライバーでのトランザクション管理
- `Session`オブジェクトの`begin_transaction`/`commit`/`rollback`は非推奨
- 代わりに`execute_write`/`execute_read`を使用する
- 例：
  ```python
  def _execute_transaction(self, work_func):
      with self._get_session() as session:
          return session.execute_write(work_func)
  ```

### エラー処理とロールバック
- トランザクションは自動的にロールバック
- 明示的な`rollback`呼び出しは不要
- エラーハンドリングは`try-except`で実装

## ノードとリレーションシップの管理
### IDの扱い
- 非推奨の`id()`関数は使用しない
- 代わりに`elementId()`を使用
- IDはノードのプロパティとして扱う場合は明示的に保存

### プロパティの制約
- 基本型（str、int、float、bool）のみサポート
- 複雑なデータ型は事前に変換が必要
- 大量のプロパティ（100以上）も処理可能

### リレーションシップ
- 双方向の関係も可能
- プロパティ付きリレーションシップをサポート
- 存在しないノード間の関係は作成不可

## テスト設計のベストプラクティス
### テストケースの分類
1. 基本機能テスト
   - CRUD操作
   - 検索機能
2. エラー処理テスト
   - 無効な入力
   - 存在しないデータ
3. 特殊ケーステスト
   - 大量データ
   - 特殊文字
   - 長文字列

### テストの前提条件
- 環境変数での設定
- テストデータの独立性
- クリーンアップの重要性

## パフォーマンスと最適化
### クエリ最適化
- インデックスの活用
- バッチ処理の利用
- 適切なトランザクション範囲

### メモリ管理
- セッションの適切なクローズ
- 大量データの分割処理
- リソースの解放

## セキュリティ考慮事項
### 認証情報
- 環境変数での管理
- 暗号化通信の使用
- 最小権限の原則

### 入力検証
- パラメータのバリデーション
- SQLインジェクション対策
- エスケープ処理

# 実装パターン
- スコープ：Neo4jManagerクラス全般
- 内容：
  1. メソッドの責務を明確に分離
  2. エラーハンドリングは3層で実施（メソッド層、トランザクション層、クエリ層）
  3. ログ出力は各層で適切に実施
- 再利用場面：
  - 新規クラス・メソッドの実装時
  - コードレビュー時の指針として 

# 開発知識データ�ース

## エラー処理・データ検証

### 文字列から数値への変換処理
- スコープ: データ型変換、特に文字列から数値への変換
- 知識内容:
  1. 文字列による定性的な値（'high', 'medium', 'low'等）を数値に変換する場合は、明示的なマッピングを定義する
  2. デフォルト値を適切に設定し、未知の値に対してもエラーにならないように処理する
  3. 変換後の値は適切な範囲（0.0-1.0等）に正規化する
- 再利用場面:
  - 定性的な評価を定量的なスコアに変換する場合
  - ユーザー入力やAPIレスポンスに文字列形式の重要度や評価値が含まれる場合

### 必須フィールドの検証
- スコープ: 入力データの検証、特にAPI応答やユーザー入力の処理
- 知識内容:
  1. 必須フィールドを明示的にリスト化し、一括でチェックする
  2. 欠落フィールドを特定し、具体的なエラーメッセージを生成する
  3. 早期にチェックを行い、後続の処理でのエラーを防ぐ
- 再利用場面:
  - 外部APIからのレスポンス処理
  - ユーザー入力のバリデーション
  - データ変換・加工の前処理

## テスト設計・実装

### テストカバレッジの効率的な向上
- スコープ: ユニットテスト、結合テスト
- 知識内容:
  1. 重要な機能から優先的にテストを実装
  2. エッジケースを含む包括的なテストケースの設計
  3. モックを活用した外部依存の分離
- 再利用場面:
  - 新機能の実装時のテスト設計
  - 既存コードのテストカバレッジ改善
  - リファクタリング時の品質保証

### エラーケースのテスト
- スコープ: 異常系テスト、エラー処理の検証
- 知識内容:
  1. 無効な入力値に対するテスト
  2. 境界値のテスト
  3. 例外処理の検証
- 再利用場面:
  - エラー処理の実装時
  - システムの堅牢性向上時
  - セキュリティ対策の実装時 

# プロジェクト知識ベース

## エラーメッセージの設計と検証
### スコープ
- Neo4jManagerを含むすべてのモジュール
- エラーハンドリングとメッセージング

### 知識内容
1. エラーメッセージの一貫性
   - エラーメッセージは具体的で明確な問題を示す必要がある
   - 同じ種類のエラーには同じメッセージパターンを使用
   - メッセージは技術的な問題を非技術者にも理解できる形で説明

2. テストによる検証
   - エラーメッセージの正確な文言をテストケースで検証
   - 異なる言語や文化圏でも理解できる明確なメッセージング
   - エラーコードとメッセージの対応関係を文書化

### 再利用場面
- 新しいエラーケースの追加時
- エラーメッセージの修正時
- APIの一貫性レビュー時

## テストカバレッジ改善戦略
### スコープ
- すべてのモジュール
- テスト設計と実装

### 知識内容
1. 段階的アプローチ
   - 基本機能のテストから開始
   - エラーケースと境界値テストを段階的に追加
   - 統合テストとパフォーマンステストは最後に実装

2. 優先順位付け
   - モジュール間の依存関係を考慮
   - ビジネスクリティカルな機能を優先
   - 技術的負債の大きい領域を優先的に改善

3. テストケースの設計
   - テストは仕様のドキュメントとしても機能
   - 各テストの目的と期待結果を明確に記述
   - テストデータは現実的なユースケースを反映

### 再利用場面
- 新機能の追加時
- レガシーコードのリファクタリング時
- テスト戦略の立案時

## 警告対応ガイドライン
### スコープ
- すべてのモジュール
- テスト実行時の警告
- ランタイム警告

### 知識内容
1. 警告の重要性
   - 警告は潜在的な問題のシグナル
   - 無視せず、根本原因の分析が必要
   - 技術的負債として記録し、計画的に対処

2. データの一意性制約
   - 複数レコード検出は設計の見直しが必要
   - 一意性制約の明示的な定義
   - データの整合性チェックの強化

3. 対処方針
   - 警告の原因を特定し文書化
   - 影響範囲の評価
   - 優先度に基づく対応計画の策定

### 再利用場面
- CI/CDパイプラインの設定時
- コードレビュー時
- パフォーマンスチューニング時 