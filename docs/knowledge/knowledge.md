# 市場分析システムの知識ベース

## エンティティ構造化
### スコープ
- app/market_analyzer.py の _create_entity メソッド

### 知識内容
1. 必須フィールド
   - id: エンティティの一意識別子
   - name: エンティティの名称
   - type: エンティティの種別（COMPANY/PRODUCT/SERVICE）
   - content: エンティティの説明内容
   - source: 情報源
   - timestamp: 作成/更新時刻
   - impact: 市場への影響度（0.0-1.0）

2. プロパティの制約
   - 既存のキーは上書きしない（データの一貫性を保持）
   - 値の型は文字列、数値、真偽値のみ許可（Neo4jの制約に準拠）

### 再利用場面
- 新規エンティティ作成時
- エンティティ構造の変更時
- データバリデーション実装時

## リレーションシップ管理
### スコープ
- app/market_analyzer.py の _validate_relationship メソッド

### 知識内容
1. 関係タイプの制約
   - INFLUENCES: 影響関係
   - COMPETES: 競合関係
   - DEVELOPS: 開発関係
   - PARTICIPATES: 参加関係

2. 必須プロパティ
   - source: 関係の起点エンティティ
   - target: 関係の終点エンティティ
   - type: 関係の種別
   - strength: 関係の強度（0.0-1.0）
   - timestamp: 作成時刻

### 再利用場面
- 新規リレーションシップ作成時
- リレーションシップのバリデーション実装時

## 市場影響度計算
### スコープ
- app/market_analyzer.py の _calculate_impact_score メソッド

### 知識内容
1. 影響度の構成要素
   - 基本スコア: 50%（エンティティの直接的な重要度）
   - トレンド影響: 30%（市場トレンドからの影響）
   - 企業動向: 20%（関連企業の動向による影響）

2. スコア正規化
   - すべての要素を0.0-1.0の範囲に正規化
   - 重み付け合算後も0.0-1.0の範囲を保証

### 再利用場面
- 影響度計算ロジックの修正時
- 新規要素の追加時
- スコアの調整時

# トレンド分析の設計と実装

## トレンド分析の評価要素

### 1. トレンドの重要度
- 市場影響度（40%）
  - Geminiの分析結果から市場への影響度を評価
  - 0.0〜1.0の範囲で数値化
- 企業重要度（40%）
  - トレンドに関連する企業の重要性を評価
  - 企業の規模、市場シェア、業界での影響力などを考慮
- 言及頻度（20%）
  - トレンドが言及される頻度を評価
  - 時系列での変化も考慮

### 2. トレンドの新規性
- 初出時期（40%）
  - トレンドが最初に言及された時期を評価
  - 最近のトレンドほど高いスコア
- 言及頻度の変化（40%）
  - 言及頻度の時系列変化を評価
  - 急激な増加は新規性が高いと判断
- 類似性（20%）
  - 既存トレンドとの類似度を評価
  - 類似性が低いほど新規性が高い

### 3. トレンドのカバレッジ
- 企業数（40%）
  - トレンドに関連する企業の総数を評価
  - より多くの企業が関与するトレンドを重視
- 市場シェア（40%）
  - 関連企業の市場シェアを評価
  - 市場シェアの大きい企業の関与を重視
- 業界分布（20%）
  - 関連企業の業界分布を評価
  - 複数業界に影響するトレンドを重視

## 実装上の注意点

### エラーハンドリング
- 各評価メソッドは独立して例外をキャッチ
- エラー発生時は中間値（0.5）を返す
- エラーログを適切に記録

### 重み付けの考え方
- 主要な評価要素には40%の重みを設定
- 補助的な要素には20%の重みを設定
- すべての重みの合計が100%になるように調整

### 正規化
- すべての評価値は0.0〜1.0の範囲に正規化
- max(0.0, min(1.0, value)) で範囲を制限

### 拡張性
- 各評価メソッドは独立して実装
- 新しい評価要素の追加が容易な設計
- 重み付けの調整が容易

# Neo4j関連の知識

## Neo4j APIの変更点と注意事項
- スコープ：Neo4jデータベース操作全般
- 内容：
  1. `id()`関数は非推奨となり、代わりに`elementId()`を使用する必要がある
  2. ノードIDの型変換は、文字列からintへの変換ではなく、elementIdをそのまま使用する
  3. トランザクション管理は`session.begin_transaction()`ではなく、`session.execute_write()`を使用する
- 再利用場面：
  - Neo4jのバージョンアップ時の移行作業
  - 新規のデータベース操作機能の実装時

## トランザクション管理のベストプラクティス
- スコープ：Neo4jManagerクラスのトランザクション処理
- 内容：
  1. 書き込み操作は`session.execute_write()`を使用
  2. 読み取り操作は`session.execute_read()`を使用
  3. 複雑なトランザクションは`_execute_unit_of_work`メソッドで管理
  4. エラー発生時は自動的にロールバックされる
- 再利用場面：
  - データベース操作を伴う新機能の実装時
  - 既存機能のリファクタリング時

## リレーションシップ作成のパターン
- スコープ：Neo4jManagerクラスのリレーションシップ操作
- 内容：
  1. ノードの存在確認を先に行う
  2. リレーションシップ作成時はCypherクエリで直接プロパティを設定
  3. エラーハンドリングは各レイヤーで適切に行う
- 再利用場面：
  - 新しいリレーションシップタイプの追加時
  - グラフデータモデルの拡張時

# 実装パターン
- スコープ：Neo4jManagerクラス全般
- 内容：
  1. メソッドの責務を明確に分離
  2. エラーハンドリングは3層で実施（メソッド層、トランザクション層、クエリ層）
  3. ログ出力は各層で適切に実施
- 再利用場面：
  - 新規クラス・メソッドの実装時
  - コードレビュー時の指針として 