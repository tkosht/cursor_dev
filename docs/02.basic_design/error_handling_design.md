# エラーハンドリング機能の基本設計

## 1. 概要
AdaptiveCrawlerクラスのエラーハンドリング機能を改善し、一貫性のある処理を実現する。

## 2. 設計方針

### 2.1 エラーハンドリングの流れ
1. エラー発生時の初期処理
   - エラーメッセージのログ出力
   - エラーコンテキストの収集

2. LLMを使用したエラー分析
   - エラーメッセージの文字列化
   - LLMManagerのanalyze_errorメソッド呼び出し
   - 分析結果のログ出力

3. リトライ戦略の決定
   - 分析結果に基づくリトライ判断
   - リトライ回数の管理
   - バックオフ時間の計算

4. 結果の返却
   - エラー情報の整形
   - コンテキストの付加
   - 分析結果の付加

### 2.2 インターフェース設計

#### _handle_error メソッド
```python
async def _handle_error(
    self,
    error: Union[str, Exception],
    context: Dict[str, Any]
) -> Dict[str, Any]:
    """エラーを処理

    Args:
        error: エラーメッセージまたは例外オブジェクト
        context: エラーコンテキスト

    Returns:
        エラー分析結果の辞書
    """
```

#### 戻り値の形式
```python
{
    'error': str,          # エラーメッセージ
    'context': Dict,       # エラーコンテキスト
    'analysis': Dict,      # LLMによる分析結果
    'should_retry': bool,  # リトライ判断
    'retry_count': int     # 現在のリトライ回数
}
```

### 2.3 エラーログ設計
- ERROR: エラーの発生
- DEBUG: エラーコンテキスト
- INFO: 分析結果、リトライ判断
- WARNING: 分析失敗時

## 3. テスト設計

### 3.1 ユニットテスト
- エラーメッセージの文字列化
- コンテキストの生成
- リトライ判断の正確性

### 3.2 統合テスト
- LLMManagerとの連携
- リトライ処理の実行
- エラー分析結果の検証

### 3.3 エラーケース
- 404エラー
- 接続エラー
- タイムアウト
- LLM分析失敗

## 4. 制約事項
- 処理時間: 10秒以内
- メモリ使用量: 最大1GB
- ログサイズ: 1エラーあたり最大1KB 