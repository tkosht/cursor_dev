# 基本設計書

本ドキュメントは、要件定義書(「docs/01.requirements/requirements.md」)に記載された要件を満たすための基本設計方針を示します。ワークフローおよび「docs/01.requirements/development_rules.md」のルールを踏まえ、実装に先立ちシステム全体像を整理しています。

---

## 1. システム概要

本システムは、指定したキーワードに関する市場分析を行うための情報を収集し、LLM(Gemini)を用いて解析し、Neo4jにナレッジとして保存する流れを実現します。  
HTML等の多様な情報源を対象として、市場動向や企業関連の情報を取得・抽出・分析したうえで、以下のように「グラフ構造」として蓄積していきます。

1. テキスト抽出  
   - HTMLソースを取得し、本文や重要要素を抽出・正規化。  
   - 広告などノイズとなる情報を除去し、目的に合ったテキストのみを対象とする。

2. Geminiによる解析  
   - gemini-2.0-flash-exp のAPIを利用して抽出したテキストを解析。  
   - 市場影響度やトレンド、企業間の関係性などを分析。

3. ナレッジ保存  
   - Neo4jに、ノード（エンティティ）やリレーションシップ（関係）として解析結果を保存。  
   - 既存のノード・リレーションシップとの関連を更新し、時系列・トレンドを追跡可能とする。

本設計書では、上記フローを満たすための機能分割とアプリケーション構造を示します。

---

## 2. 全体アーキテクチャ

本システムは以下のレイヤ構造を想定しています。

1. 収集・抽出レイヤ (ContentFetcher, ContentParser)  
   - 指定されたURL等からHTML等のソースを取得し、テキスト抽出・正規化する。  
   - Pythonで実装し、ユニットテストではHTML構造や文字コードなどを細かく検証。

2. 分析レイヤ (GeminiAnalyzer, MarketAnalyzer)  
   - 抽出テキストをGemini(gemini-2.0-flash-exp)に渡し、要点抽出・市場影響評価・トレンド特定などを行う。  
   - 分析結果を内部フォーマット（例：dictやクラスインスタンス）へ一時保持。

3. データ保持レイヤ (Neo4jManager, KnowledgeRepository)  
   - 分析結果をNeo4jへノード・リレーションシップとして登録・更新する。  
   - 既存ノードとの重複チェック、リレーションシップの更新や追記などのロジックを実装。

4. ユーティリティ (共通関数、バリデーション、例外処理など)  
   - 共通的に利用するロガー設定、バリデーション関数等をまとめる。
   - エラーや例外発生時の通知・ログ出力・リトライなどの基本処理を一元化。

---

## 3. 主なコンポーネント設計

### 3.1 ContentFetcher  
- 役割: 指定されたURLやファイルパスからHTML情報を取得。  
- 主な責務:  
  1. HTTPリクエストの送信およびレスポンス受信  
  2. ステータスコード確認、リトライ、タイムアウトなど基本的なネットワーク処理  
  3. 取得エラー時の適切な例外送出やログ記録

### 3.2 ContentParser  
- 役割: 取得したHTMLやテキストを解析し、本文や重要要素を抽出・正規化する。  
- 主な責務:  
  1. 不要要素（広告・スクリプト・ナビゲーションなど）の除去  
  2. データ構造化（本文、タイトル、見出し、日付など）  
  3. テキストクレンジング（改行調整、余分なスペース除去など）

### 3.3 GeminiAnalyzer  
- 役割: Gemini API(gemini-2.0-flash-exp)を用いて抽出テキストを解析し、市場影響度やトレンドなどを考慮して情報を付加する。  
- 主な責務:  
  1. Gemini APIの呼び出し  
  2. 分析パラメータ(プロンプト)の生成  
  3. 取得した解析結果のパースと整形  
  4. 分析結果をMarketAnalyzer向けに受け渡す形式へ変換

### 3.4 MarketAnalyzer  
- 役割: GeminiAnalyzerの結果をベースに、市場影響度・企業動向・関係性などを整理する。  
- 主な責務:  
  1. 分析結果(LLMレスポンス)の要点抽出  
  2. 企業名や製品名などのエンティティ検出  
  3. エンティティ間のリレーションや影響度算出  
  4. レポーティング用やデータ保存用に最終的なデータ形式へまとめる

### 3.5 Neo4jManager  
- 役割: Neo4jとの接続管理、およびクエリの実行。  
- 主な責務:  
  1. 環境変数（neo4j_user、neo4j_pswd、ホストなど）を利用し、認証や接続設定を行う  
  2. ノードやリレーションシップの新規登録・更新・取得  
  3. エラーや重複チェック

### 3.6 KnowledgeRepository  
- 役割: Neo4jManagerを用いて実際にエンティティやリレーションのCRUD操作を行う処理をカプセル化。  
- 主な責務:  
  1. 分析結果(MarketAnalyzerの出力)をもとに、対応するノード・リレーションシップを作成  
  2. 既存のノード・リレーションシップとの一致・重複チェック  
  3. 更新時の時系列管理（timestamp プロパティ）やバージョン管理対応

---

## 4. データモデル・スキーマ（Neo4j想定）

大まかなノードとリレーションシップは下記のように設計します。

- Node: 「Company」「Article」「Trend」など  
  - 共通プロパティ例: content（内容）, source（URLや記事タイトル等）, timestamp（解析時刻）, impact（市場への影響度）  
- Relationship: 「INFLUENCES」「COMPETES」「PARTICIPATES」など  
  - 共通プロパティ例: description（関係の説明）, strength（関係強度）

ノード・リレーション共に、上書きではなく必要に応じて更新・追加更新することで過去の履歴やトレンドの変化を活用します。

---

## 5. セキュリティ・運用面

- 機密情報（Neo4jのユーザ名・パスワード、GeminiのAPIキー）は .env に格納し、Pythonアプリ上でのみ os.getenv() を通して取得します。  
- パスワードは表示禁止。LLMへの送信も禁止。  
- 接続周りのエラーが発生した場合は安易に外部要因と断定せず、まずは自身の接続設定や環境変数の内容（変数名・スペルなど）を徹底的に確認する。  
- SQLインジェクション相当の攻撃（Cypherインジェクション）への備えとして、クエリパラメータバインディングを厳密に行う。

---

## 6. テスト方針

1. ユニットテスト:  
   - 関数単位でテスト。ContentFetcherやContentParserなどに対して想定外入力や例外パターンも網羅。  
   - GeminiAnalyzerやNeo4jManagerの疎通なども、モジュールごとに固定レスポンスや簡易接続テストを組み合わせて確認する。

2. 結合テスト・統合テスト:  
   - 実際のGeminiサービス(gemini-2.0-flash-exp)を使用した本番同等テストを行い、解析結果からNeo4jへの書き込みまで一連を確かめる。  
   - モック利用は単体テスト等に留め、結合テストではモック禁止。

3. カバレッジと品質管理:  
   - pytestでテスト実行し、カバレッジ80％以上を確保。  
   - flake8とblackによるLint/Formatterを厳守し、DRY・SOLID・YAGNI・KISSの観点で不要・重複箇所がないかを都度チェック。

---

## 7. 今後のステップ

- 本基本設計を踏まえ、詳細設計(「docs/03.detail_design/」)で各クラス・メソッドのインタフェースやデータフローを具体化します。  
- その後、ワークフロー (step_number: 2) に従い、各Pythonクラスを「app/」ディレクトリへ実装します。  
- セキュリティ・品質管理ルールに従った継続的なコードレビュー・テストを実施します。

以上が、要件および開発ルールに基づいた基本設計書の概要です。今後は詳細設計書で具体的なメソッドやデータ構造を定義し、必要に応じて本設計書も更新します。 
